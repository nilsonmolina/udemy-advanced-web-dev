<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Documentation</title>
    <link rel="stylesheet" href="style.css">
    <!-- <link rel="stylesheet" href="prism/prism.css"> -->
    <link rel="stylesheet" href="prism/prism-atom-theme.css">
    <link href="https://fonts.googleapis.com/css?family=Raleway:300,400,600,900" rel="stylesheet">
</head>
<body>
    <div class="background-left"></div>
    <div class="wrapper">
        <div class="sidebar">
            <div class="items">
                <a href="#intro">Intro</a>
                <a href="#animations">Animations</a>
                <a href="#flexbox">Flexbox</a>
                <a href="#async-js">Async JS</a>
                <a href="#advanced-js">Advanced JS</a>
                <a href="#node-mongo">Node and Mongo</a>
                <a href="#d3">D3</a>
                <a href="#react">React</a>
                <a href="#projects">Projects</a>              
            </div>
            <div class="responsive-btn"></div>
        </div>
        <div class="content">
            <div class="container">
                <div class="header">
                    <span><strong>Udemy Course:</strong> Advanced Web Developer Bootcamp</span>
                    <div><strong>Design Inspiration: </strong><a href="https://dribbble.com/shots/3352932-Intro-screen-Code-or-not-to-code" class="acknowledgement" target="_blank">Dribble Design by Olia Gozha</a></div>                    
                    <h1 class="title">Study Guide</h1>
                </div>
    
                <h2 id="intro">Intro</h2>
                <p>
                    This section will introduce the topics that I have learned during my time with this course.  It will continually be updated throughout my progress with the course.
                </p>
    
                <hr />
                <h2 id="animations">CSS Animations</h2>
                <p>
                    Animations with CSS can many times be more of an art-form than web development.  Some examples of beautiful CSS animation designs can be found at the following sites: 
                </p>
                <ul>
                    <li><a href="http://www.species-in-pieces.com" target="_blank">In Pieces: 30 Species, 30 Pieces</a></li>
                    <li><a href="http://www.waaark.com" target="_blank">Waaark creative web studio</a></li>
                </ul>            
                <p>
                    However, most web developers generally don't spend much of their time with stunningly beautiful design. Instead, most web developers work on much more subtle animations, that "inform" the user without having to necessarily "tell" the user. Simple things that most people don't notice, but are imperative for ease of use. A good article advocating "why" animations are important in UI design, is <a href="https://medium.com/bridge-collection/improve-the-payment-experience-with-animations-3d1b0a9b810e" target="_blank">this one on Medium</a> written by User Interface Developer working at Stripe. <em class="yellow">Getting things to move is easy, but planning or designing how they should move is the hard part.</em>
                </p>
    
                <h3>CSS3 Psuedo-classes</h3>
                <p>
                    Before we jump into animating CSS, lets talk about ways to trigger animations. One such way is to use <em class="yellow">CSS3 Psuedo-classes, which are selectors that specify a special state of the selected element(s). </em> A full list of pseudo-classes can be found on the MDN site, but we will be focusing on just 3 for now:
                </p>
                <pre><code class="language-css">div:hover { 
    cursor: pointer;
}</code></pre>
                <p>
                    <em class="blue"><strong>Hover</strong> is triggered by a user mousing over the specific element.</em> This one is pretty simple and quite useful, though it is typically not triggered on mobile devices since those devices are usually touch based, not mouse based.
                </p>
                <pre><code class="language-css">input:focus { 
    color: red;
}</code></pre>
                <p>
                    <em class="green"><strong>Focus</strong> is triggered when an element "receives focus."</em> It is generally triggered when the user clicks or taps on an element or selects it with the keyboard's tab key.
                </p>
                <pre><code class="language-css">button:active { 
    background: purple;
}</code></pre>
                <p>
                    <em class="purple"><strong>Active</strong> is triggered when an element is "being activated by the user."</em> This one can be a bit confusing, but a simple example of when this is triggered, can be seen when you hold down the mouse click on a button.
                </p>
                <p>To solidify what we have learned, we performed the following exercises:</p>
                <ul>
                    <li><a class="internal" href="02-intro-to-animations/psuedoclass-exercise/index.html" target="_blank">psuedoclass-exercise</a></li>
                    <li><a class="internal" href="02-intro-to-animations/animated-button/index.html" target="_blank">build an animated button</a></li>
                </ul>
    
                <h3>CSS3 Transforms</h3>
                <p>
                    Transform lets you manipulate the coordinate space of the CSS visual formatting model.  In other words, <em class="yellow">transforms let you move, warp, rotate and scale elements.</em>  When using transforms, you typically pass it a function that you'd like to have performed. A full list of the functions that can be found on the MDN site, but we will discuss a few of the popular ones below.
                </p>
                <pre><code class="language-css">div { 
    transform: translateX(100px);
    transform: translateY(300px);
    transform: translate(100px, 300px); /* same as both above in one line */
}</code></pre>
                <p>
                    <em class="blue"><strong>Translate</strong> moves an element.</em> We did a few examples to get a good understanding of the translate function here: <a class="internal" href="02-intro-to-animations/transform-basics/translate.html" target="_blank">Transform: Translate.</a> An important thing to note with translate is that it should be used when you want to animate something and not for basic positioning.  This is because, the initial origin of that element will remain at the location, before the translation is performed. You can see how this is a problem when you try and highlight one of the boxes in the example link above. <em class="blue">So put an element where you want it first, and then perform any translations</em>.  You shouldn't try to do a translate on a translated element.
                </p>
                <pre><code class="language-css">div { 
    transform: scaleX(2); /* doubles width*/
    transform: scaleY(0.5) /* halves height */
    transform: scale(2, 0.5) /* halves width, doubles height */
    transform-origin: left /* determines where scale starts*/
}</code></pre>
                <p>
                    <em class="green"><strong>Scale</strong> alters the size of an element.</em> We did a few examples to get a good understanding of the scale function here: <a class="internal" href="02-intro-to-animations/transform-basics/scale.html" target="_blank">Transform: Scale.</a> Something to keep in mind is that scale affects every aspect of the element, including the border, font, padding, etc... The default origin of the transfrom is at the center (both vertically and horizontally), so the element grows outward from the center.  We can change that by using the transform-origin property. <em class="green">Transform-origin can be used to determine the location of where the scale occurs from.</em>
                </p>
                <pre><code class="language-css">div { 
    transform: rotate(45deg);
}</code></pre>
                <p>
                    <em class="purple"><strong>Rotate</strong> allows us to... rotate things.</em> We did a few examples to get a good understanding of the rotate function here: <a class="internal" href="02-intro-to-animations/transform-basics/rotations.html" target="_blank">Transform: Rotate.</a> Positive degrees are clockwise rotations while negative degrees are counter-clockwise rotations. <em class="purple">Transform-origin can be used to determine the location of where the rotate occurs from.</em>
                </p>
                <pre><code class="language-css">div { 
    /* scale would overwrite rotate if below code is used */
    transform: rotate(90deg);
    transform: scale(2);
    /* proper way - overwrites both transforms above */
    transform: rotate(90deg) scale(2);    
}</code></pre>
                <p>
                    If you tried to apply two transformations on different lines, the second transform will actually overwrite the first transform. In order to get around this, you would have to <em class="yellow">place all transformations on a single transform</em> as shown above.
                </p>
                <pre><code class="language-css">div { 
    -webkit-transform: rotate(180deg);
        -ms-transform: rotate(180deg);
            transform: rotate(180deg);
}</code></pre>
                <p>
                    <em class="yellow">Vendor prefixes are needed</em>, because as more experimental CSS properties are created, not all browsers implement them the same way or at the same time. But they clutter your workspace and can get tedious writing them all out. Also, keeping track of which are needed and which aren't is a big pain point.  To get around this, <em class="yellow">it is best to use an auto-prefixer.</em> The following is a website where you can type some code in and see the prefixes that are needed or not needed: <a href="http://autoprefixer.github.io/" target="_blank">autoprefixer</a>
                </p>
    
                <h3>CSS Transitions</h3>
                <p>
                    We have been translating, scaling, rotating, essentially moving things around, but we haven't been able to animate something yet.  We can rotate an element, but it's instantaneous and NOT animated.  <em class="yellow">Transitions allow us to control animation speed (and a few other properties) when changing CSS properties.</em> The following are the 4 transition properties that we can set for an animation:
                </p>
                <pre><code class="language-css">div { 
    transition-duration: 1s;
    transition-duration: 0.5s;
    transition-duration: 3s, 1s;

    transition-property: background;
    transition-property: transform;
    transition-property: all;
    transition-property: color, opacity;

    transition-delay: 4s;
    transition-delay: 5ms, 10s;

    transition-timing-function: ease-in;
    transition-timing-function: ease-out;
    transition-timing-function: linear;
}</code></pre>
                <p>
                    <em class="blue">transition-duration is how long the transition should last.</em> You can have multiple durations if you have declared multiple different properties in your transition-property. <em class="green">transition-property allows us to specify which property should be transitioned.</em> Something to keep in mind when using transition-property is that you cannot specify just rotate or scale, and must instead use the generic transform. <em class="purple">transition-delay allows you to set how long of a pause before the transition begins.</em> You can have multiple durations if you have declared multiple different properties in your transition-property, similar to transition-duration.<em class="yellow">transition-timing-function allows you to control the "acceleration curve" for the transition.</em>  Some great examples of this can be found on the <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/transition-timing-function" target="_blank">MDN website.</a>
                </p>
                <pre><code class="language-css">div {
    /* transition: [property] [duration] [timing-function] [delay] */
    transition: opacity 1.5s ease-in 1;
}</code></pre>
                <p>
                    Instead of having to write out each of the 4 transition properties, we can simply use the shorthand for transitions as seen above. We did a few examples to get a better understanding of transitions here: <a class="internal" href="02-intro-to-animations/transition-basics/index.html" target="_blank">Transition: Basics</a>
                </p>
                <p> 
                    Although many properties can be transitioned, there are some that cannot.  A more important question however, is what properties "should" be transitioned.  <em class="yellow">If you are concerned with performance, these are the 4 properties that are recommended to be animated or transitioned</em>, all other properties have a performance hit.
                </p>
                <ol>
                    <li>transform: translate()</li>
                    <li>transform: scale()</li>
                    <li>transform: rotate()</li>
                    <li>opacity;</li>
                </ol>
                <p>
                    For more information on why all other properties are less performant, you can read this <a href="https://www.html5rocks.com/en/tutorials/speed/high-performance-animations/" target="_blank">article.</a> 
                </p>
                <p>
                    <a class="internal" href="02-intro-to-animations/transition-exercise/index.html" target="_blank">Transition: Final Exercise</a>
                </p>
    
                <h3>CSS Keyframe Animation</h3>
                <p>
                    Like transitions, keyframes are another tool in our CSS animation arsenal, but unlike transitions, they allow us to build much more complex and multi-component, multi-state animations. <em class="yellow">Transitions allow us to animate a single state change, keyframes allow for much more complex multi-state animations.</em> A very basic, and admittedly ugly, example of an animation was done here: <a class="internal" href="03-keyframes/basics/ugly-rainbow.html" target="_blank">Keyframe Basics</a>
                </p>
                <div class="media">
                    <img src="03-keyframes/imgs/keyframes-diagram-01.png" alt="">
                </div>
                <pre><code class="language-css">@keyframes rainbowtext {
    0% {
        color: red;
        font-size: 20px;
    }
    50% {
        color: orange;
        font-size: 40px;
    }
    100% {
        color: blue;
        font-size: 20px;
    }
}</code></pre>
                <p>
                    <em class="yellow">The first step in setting up keyframes is to define the keyframes.</em>  When defining the the keyframes, you can choose any percentage step between 0 and 100.
                </p>
                <pre><code class="language-css">div {
    /* The usual animation properties */
    animation-name: rainbowtext;
    animation-duration: 3s;
    animation-timing-function: linear;
    animation-delay: 0s;
    
    /* The "newer" animation properties */
    animation-iteration-count: infinite;
    animation-fill-mode: forwards;
    animation-direction: forward;
    animation-play-state: paused;
}</code></pre>
                <p>
                    <em class="yellow">The second step is to apply the animation</em>  Something important to note, is that there is nothing triggering the example animation above.  As soon as the page loads, the animation will start running. Also, many of the properties are similar to transitions, except for 4 new ones. The 'animation-iteration-count' property is pretty simple to understand, you just use an integer or infinite to define how many times the animation should run. In fact, here is a small demo for the animation-iteration property: <a class="internal" href="03-keyframes/basics/iteration.html" target="_blank">animation-iteration demo</a>.  However, we will go into a bit more depth with the other three.
                </p>
                <pre><code class="language-css">div {
    animation-direction: forward;
    animation-direction: reverse;
    animation-direction: alternate;
}</code></pre>
                <p>
                    <em class="blue">The animation-direction property allows us to have the animation run in reverse or even alternate</em>, which would cause it to animate forward normally, and then reverse back to the original state.  It's a bit easier to see in practice, so here is an example that we worked on: <a class="internal" href="03-keyframes/basics/direction.html" target="_blank">animation-direction demo</a>
                </p>
                <pre><code class="language-css">div {
    animation-fill-mode: forwards;
    animation-fill-mode: backwards;
    animation-fill-mode: both;
    animation-fill-mode: none;
}</code></pre>
                <p>
                    <em class="green">The animation-fill-mode property specifies how an animation should apply styles before and after the animation.</em>  It's hard to explain, so this demo helps illustrate how it works: <a class="internal" href="03-keyframes/basics/fill-mode.html" target="_blank">animation-fill-mode demo</a>. The forwards option is particularly useful when you want to run an animation one time, and then have it stay in that end state instead of having it snap back to the initial state.
                </p>
                <pre><code class="language-css">div {
    animation-play-state: paused;
    animation-play-state: running;
}</code></pre>
                <p>
                    <em class="purple">The animation-play-state property specifies whether the animation is running or paused.</em> Many times, this property is manipulated in javascript, but to keep things simple, we used the css 'hover' pseudoclass: <a class="internal" href="03-keyframes/basics/play-state.html" target="_blank">animation-play-state demo</a>
                </p>
                <pre><code class="language-css">div {
    /* first time value always goes to duration, second goes to delay */
    animation: 3s ease-in 1s 2 reverse both paused slidin;
    animation: changecolor 3s linear 1s infinite;
    animation: jiggle 4s;
}</code></pre>
                <p>
                    <em class="yellow">You can use shorthand when writing animations</em>, but if you are using many properties, it can get quite dificult to read.  The order kind of matters, but it also kind of doesn't. For example, the first value that can be parsed as a time is assigned to the animation-duration property and the second one is assigned to animation-delay. But other than that, as long as your animation-name does not conflict with the other properties, the order does not matter.
                </p>
                <p>To solidify what we have learned, we performed the following exercises:</p>
                <ul>
                    <li><a class="internal" href="03-keyframes/exercise-rising-sun/index.html" target="_blank">Rising Sun Exercise</a></li>
                    <li><a class="internal" href="03-keyframes/exercise-css-loader/index.html" target="_blank">CSS Loader</a></li>
                </ul>

                <hr />
                <h2 id="flexbox">Flexbox</h2>
                <p>
                    Layout has long been a pain point for web developers, and many have often turned to css frameworks like bootstrap or foundation to help make sense of the mess.  Until recently that is, with the introduction of flexbox and grid layout systems, building responsive layouts is easier than its ever been. It's a newish layout module that has been around for a couple of years, but wasn't widely adopted by the major browsers until now. <em class="yellow">Flexbox is a more efficient way to lay out, align and distribute space among items in a container... even if their size is unknown.</em> The days of weird and hacky tricks using floats, clearfixes and tables to layout a page are finally gone. There is a bit of syntax to learn, and it may be a bit tricky in the beginning, but once you get passed that, layouts will be so much easier than they've ever been. A great reference for flexbox and it's many properties can be found at <a href="https://css-tricks.com/snippets/css/a-guide-to-flexbox/" target="_blank">CSS-Tricks.</a> 
                </p>
                <pre><code class="language-css">/* Container Properties */
    flex-direction
    justify-content
    flex-wrap 
    align-items 
    align-content
/* Flex Item Properties */
    order 
    flex 
    flex-grow 
    flex-shrink 
    align-self </code></pre>
                <p>
                    Before we start, it's important to note that <em class="yellow">there are two types of properties for flex; the properties that apply to containers and those that apply to the individual items within the container.</em>
                </p>
                <h3>Flex Container Properties</h3>
                <p>
                    Below is an illustration of the terminology that will be used when discussing the various flex properties. These are also the default directions for the main axis and the cross axis.
                </p>
                <div class="media">
                    <img src="04-flexbox/imgs/flex-terminology.png" alt="">
                </div>                
                <pre><code class="language-css">.container {
    display: flex;
}</code></pre>
                <p>
                    To start using flex, all you need to do is set the display property of a container to flex. It really is that simple, the tricky part is configuring flex properly to fit your needs. 
                </p>
                <pre><code class="language-css">.container {
    display: flex;
    flex-direction: row; /* default value */
    flex-direction: row-reverse;
    flex-direction: column;
    flex-direction: column-reverse;
}</code></pre>
                <p>
                    <em class="blue">flex-direction specifies how items are placed in the flex container, defining the main axis and it's direction.</em> To get some practice with this, we did the following example: <a class="internal" href="04-flexbox/basics/flex-direction.html" target="_blank">flex-direction</a>
                </p>
                <pre><code class="language-css">.container {
    display: flex;
    flex-wrap: no-wrap; /* default value */
    flex-wrap: wrap;
}</code></pre>
                <p>
                    <em class="green">flex-wrap specifies whether items are forced into a single line OR can be wrapped into multiple lines.</em> To get some practice with this, we did the following example: <a class="internal" href="04-flexbox/basics/flex-wrap.html" target="_blank">flex-wrap</a>. When doing our example, we found that if we made our flex-item width's really big, flex would only allow them to get as big as the container allows.  If we made the containers too small, the flex-items would break free as well.
                </p>
                <pre><code class="language-css">.container {
    display: flex;
    justify-content: flex-start; /* default value */
    justify-content: flex-end;
    justify-content: center;
    justify-content: space-between;
    justify-content: space-around;
}</code></pre>
                <p>
                    <em class="purple">justify-content defines how space is distributed between items in flex containers, ALONG THE MAIN AXIS.</em> To get some practice with this, we did the following example: <a class="internal" href="04-flexbox/basics/justify-content.html" target="_blank">justify-content</a>.
                </p>

                <p>
                    Before moving on, we wanted to practice what we have learned by doing a quick exercise: <a class="internal" href="04-flexbox/exercise-sidebar/index.html" target="_blank">Exercise: Sidebar</a>.
                </p>
                <pre><code class="language-css">.container {
    display: flex;
    align-items: stretch; /* default value */
    align-items: flex-start;
    align-items: flex-end;
    align-items: center;
    align-items: baseline;
}</code></pre>
                <p>
                    <em class="red">align-items defines how space is distributed BETWEEN ITEMS in flex containers, ALONG THE CROSS AXIS.</em> It is very similar to the justify-content property, but align-items works on the cross axis instead of the main axis. We practiced this a bit here: <a class="internal" href="04-flexbox/basics/align-items.html" target="_blank">align-items</a>.
                </p>
                <pre><code class="language-css">.container {
    display: flex;
    align-content: stretch; /* default value */
    align-content: flex-start;
    align-content: flex-end;
    align-content: space-between;
    align-content: space-around;
    align-content: center;    
}</code></pre>
                <p>
                    <em class="orange">align-content defines how space is distributed BETWEEN ROWS in flex containers, ALONG THE CROSS AXIS.</em> The unfortunate name of this property makes it easy to be confused with the align-items property.  So if we don't have multiple rows or any wrapping, then we won't have any space between the rows. Essentially, <em class="orange">this property only works if wrap is used, because it only affects the space between rows</em>. We practiced this a bit here: <a class="internal" href="04-flexbox/basics/align-content.html" target="_blank">align-content</a>.
                </p>
                <p>
                    To solidify what we have learned, we tried making a very simple navbar using flexbox: <a class="internal" href="04-flexbox/exercise-navbar/index.html" target="_blank">Exercise: Navbar</a>.
                </p>

                <h3>Flex Item Properties</h3>
                <p>Up to this point, we have learned how to define flex container properties. Now we are going to take a look at the flex item properties so that we have control on the individual elements.</p>

                <pre><code class="language-css">.box-1 {
    display: flex;
    align-self: stretch; /* default value */
    align-self: flex-start;
    align-self: flex-end;
    align-self: center;
    align-self: baseline;
}</code></pre>
                <p>
                    <em class="blue">align-self allows you to override align-items on individual flex items, long the cross axis.</em> It is very similar to the align-items property, but align-self affects only the individual item. We practiced this a bit here: <a class="internal" href="04-flexbox/basics/align-self.html" target="_blank">align-self</a>.
                </p>

                <pre><code class="language-css">.box-1 {
    display: flex;
    order: 2;
}</code></pre>
                <p>
                    <em class="green">order specifies the order used to lay out items in their flex container.</em> If you were to use the code example up top, box-1 would move all the way to the right, not to the second position.  This is because <em class="green">all items by default have an order of 0.</em> Setting something to an order of -1 would move it all the way to the left.  Also, if the row or column is reversed, then the order is also reversed. We practiced this a bit here: <a class="internal" href="04-flexbox/basics/order.html" target="_blank">order</a>.
                </p>
                <pre><code class="language-css">.box-1 {
    display: flex;
    flex-grow: 0; /* default value */
    flex-shrink: 1; /* default value */
    flex-basis: 100px;
    flex: 0 1 100px; /* flex: [flex-grow] [flex-shrink] [flex-basis] */
}</code></pre>
                <p>
                    Up to this point, all items have been the same size, but that can be changed using flexbox. <em class="yellow">flex defines how a flex item will grow or shrink to fit the available space in a container.</em> flex is actually a shorthand property for:
                </p>
                <ol>
                    <li>
                        <em class="blue">flex-basis specifies the ideal size of a flex-item BEFORE it is placed into a flex container.</em> It's sort of like width, but it isn't. We can set flex-basis as the hypothetical ideal width, before they are placed in the container. A key distinction is that flex-basis is like width when working with rows, but it's like height when working with columns. We practiced this a bit here: <a class="internal" href="04-flexbox/basics/flex-basis.html" target="_blank">flex-basis</a>.
                    </li>
                    <li>
                        <em class="green">flex-grow dictates how the unused space should be spread amongst flex items... and its all about ratios.</em> With flex-basis, there will sometimes be a lot of extra space left over, so flex-grow allows you to specify how the left over space gets separated among the items. If box-1 has flex-grow of 1 and box-2 has flex-grow of 2, that does not always mean that it will be twice as big; it means that it will use twice as much of the available space. We practiced this a bit here: <a class="internal" href="04-flexbox/basics/flex-grow.html" target="_blank">flex-grow</a>.
                    </li>
                    <li>
                        <em class="purple">flex-shrink dictates how items should shrink when there isn't enough space in the container.</em> Setting a flex-shrink to 0 prevents that item from shrinking and will even cause the items to break out of their containers. We practiced this a bit here: <a class="internal" href="04-flexbox/basics/flex-shrink.html" target="_blank">flex-shrink</a>.
                    </li>
                </ol>
                <p>
                    Most times, the shorthand is used rather than the individual properties, but it was a good way to learn the different properties.  To practice we did the following two exercises:
                </p>
                <ul>
                    <li><a class="internal" href="04-flexbox/exercise-polygon-widget/index.html" target="_blank">Polygon.com widget</a>.</li>
                    <li><a class="internal" href="04-flexbox/exercise-holy-grail/index.html" target="_blank">Holy Grail Layout</a>.</li>
                </ul>
                <p>Lastly, here are some links to practice the use of flexbox and css grids (which was not talked about in this course):</p>
                <ul>
                    <li><a href="http://flexboxfroggy.com/" target="_blank">Flexbox Froggy</a></li>
                    <li><a href="http://cssgridgarden.com/" target="_blank">Grid Garden</a></li>
                </ul>

                <hr />
                <h2 id="async-js">Asynchronous Javascript</h2>
                <p>
                    I haven't gotten here yet... coming soon.
                </p>
    
                <hr />
                <h2 id="advanced-js">Advanced Javascript</h2>
                <p>
                    I haven't gotten here yet... coming soon.
                </p>
    
                <hr />
                <h2 id="node-mongo">Node and MongoDB</h2>
                <p>
                    I haven't gotten here yet... coming soon.
                </p>
    
                <hr />
                <h2 id="d3">D3 Data Visualization</h2>
                <p>
                    I haven't gotten here yet... coming soon.
                </p>
    
                <hr />
                <h2 id="react">React and Redux</h2>
                <p>
                    I haven't gotten here yet... coming soon.
                </p>
    
                <hr />
                <h2 id="projects">Projects</h2>
                <p>
                    Throughout the course, we occasionally engaged in larger projects to better establish what we have learned and also to get the chance to put our new skills to practice.
                </p>
                <h3>CSS: Building A Startup Site</h3>
                <p>
                    This project required us to build a sample marketing page for a website that offers adventure tours in the mountains. When the page is loaded, a couple of css animations fade into view and a beautiful image takes center stage.  You can also scroll down the page to see more details on the mountain adventures. This site uses flexbox and is also responsive.
                </p>
                <p><a class="internal" href="05-startup-site/index.html" target="_blank">Building a Startup Site</a></p>
            </div>
        </div>
    </div>

    <script src="prism/prism.js"></script>
    <script src="script.js"></script>
</body>
</html>