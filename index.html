<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Documentation</title>
    <link rel="stylesheet" href="style.css">
    <!-- <link rel="stylesheet" href="prism/prism.css"> -->
    <link rel="stylesheet" href="prism/prism-atom-theme.css">
    <link href="https://fonts.googleapis.com/css?family=Raleway:300,400,600,900" rel="stylesheet">
</head>
<body>
    <div class="background-left"></div>
    <div class="wrapper">
        <div class="sidebar">
            <div class="items">
                <a href="#intro">Intro</a>
                <a href="#animations">Animations</a>
                <a href="#flexbox">Flexbox</a>
                <a href="#async-js">Async JS</a>
                <a href="#advanced-js">Advanced JS</a>
                <a href="#node-mongo">Node and Mongo</a>
                <a href="#d3">D3</a>
                <a href="#react">React</a>
                <a href="#projects">Projects</a>              
            </div>
            <div class="responsive-btn"></div>
        </div>
        <div class="content">
            <div class="container">
                <div class="header">
                    <span><strong>Udemy Course:</strong> Advanced Web Developer Bootcamp</span>
                    <div><strong>Design Inspiration: </strong><a href="https://dribbble.com/shots/3352932-Intro-screen-Code-or-not-to-code" class="acknowledgement" target="_blank">Dribble Design by Olia Gozha</a></div>                    
                    <h1 class="title">Study Guide</h1>
                </div>
    
                <h2 id="intro">Intro</h2>
                <p>
                    This section will introduce the topics that I have learned during my time with this course.  It will continually be updated throughout my progress with the course.
                </p>
    
                <hr />
                <h2 id="animations">CSS Animations</h2>
                <p>
                    Animations with CSS can many times be more of an art-form than web development.  Some examples of beautiful CSS animation designs can be found at the following sites: 
                </p>
                <ul>
                    <li><a href="http://www.species-in-pieces.com" target="_blank">In Pieces: 30 Species, 30 Pieces</a></li>
                    <li><a href="http://www.waaark.com" target="_blank">Waaark creative web studio</a></li>
                </ul>            
                <p>
                    However, most web developers generally don't spend much of their time with stunningly beautiful design. Instead, most web developers work on much more subtle animations, that "inform" the user without having to necessarily "tell" the user. Simple things that most people don't notice, but are imperative for ease of use. A good article advocating "why" animations are important in UI design, is <a href="https://medium.com/bridge-collection/improve-the-payment-experience-with-animations-3d1b0a9b810e" target="_blank">this one on Medium</a> written by User Interface Developer working at Stripe. <em class="yellow">Getting things to move is easy, but planning or designing how they should move is the hard part.</em>
                </p>
    
                <h3>CSS3 Psuedo-classes</h3>
                <p>
                    Before we jump into animating CSS, lets talk about ways to trigger animations. One such way is to use <em class="yellow">CSS3 Psuedo-classes, which are selectors that specify a special state of the selected element(s). </em> A full list of pseudo-classes can be found on the MDN site, but we will be focusing on just 3 for now:
                </p>
                <pre><code class="language-css">div:hover { 
    cursor: pointer;
}</code></pre>
                <p>
                    <em class="blue"><strong>Hover</strong> is triggered by a user mousing over the specific element.</em> This one is pretty simple and quite useful, though it is typically not triggered on mobile devices since those devices are usually touch based, not mouse based.
                </p>
                <pre><code class="language-css">input:focus { 
    color: red;
}</code></pre>
                <p>
                    <em class="green"><strong>Focus</strong> is triggered when an element "receives focus."</em> It is generally triggered when the user clicks or taps on an element or selects it with the keyboard's tab key.
                </p>
                <pre><code class="language-css">button:active { 
    background: purple;
}</code></pre>
                <p>
                    <em class="purple"><strong>Active</strong> is triggered when an element is "being activated by the user."</em> This one can be a bit confusing, but a simple example of when this is triggered, can be seen when you hold down the mouse click on a button.
                </p>
                <p>To solidify what we have learned, we performed the following exercises:</p>
                <ul>
                    <li><a class="internal" href="02-intro-to-animations/psuedoclass-exercise/index.html" target="_blank">psuedoclass-exercise</a></li>
                    <li><a class="internal" href="02-intro-to-animations/animated-button/index.html" target="_blank">build an animated button</a></li>
                </ul>
    
                <h3>CSS3 Transforms</h3>
                <p>
                    Transform lets you manipulate the coordinate space of the CSS visual formatting model.  In other words, <em class="yellow">transforms let you move, warp, rotate and scale elements.</em>  When using transforms, you typically pass it a function that you'd like to have performed. A full list of the functions that can be found on the MDN site, but we will discuss a few of the popular ones below.
                </p>
                <pre><code class="language-css">div { 
    transform: translateX(100px);
    transform: translateY(300px);
    transform: translate(100px, 300px); /* same as both above in one line */
}</code></pre>
                <p>
                    <em class="blue"><strong>Translate</strong> moves an element.</em> We did a few examples to get a good understanding of the translate function here: <a class="internal" href="02-intro-to-animations/transform-basics/translate.html" target="_blank">Transform: Translate.</a> An important thing to note with translate is that it should be used when you want to animate something and not for basic positioning.  This is because, the initial origin of that element will remain at the location, before the translation is performed. You can see how this is a problem when you try and highlight one of the boxes in the example link above. <em class="blue">So put an element where you want it first, and then perform any translations</em>.  You shouldn't try to do a translate on a translated element.
                </p>
                <pre><code class="language-css">div { 
    transform: scaleX(2); /* doubles width*/
    transform: scaleY(0.5) /* halves height */
    transform: scale(2, 0.5) /* halves width, doubles height */
    transform-origin: left /* determines where scale starts*/
}</code></pre>
                <p>
                    <em class="green"><strong>Scale</strong> alters the size of an element.</em> We did a few examples to get a good understanding of the scale function here: <a class="internal" href="02-intro-to-animations/transform-basics/scale.html" target="_blank">Transform: Scale.</a> Something to keep in mind is that scale affects every aspect of the element, including the border, font, padding, etc... The default origin of the transfrom is at the center (both vertically and horizontally), so the element grows outward from the center.  We can change that by using the transform-origin property. <em class="green">Transform-origin can be used to determine the location of where the scale occurs from.</em>
                </p>
                <pre><code class="language-css">div { 
    transform: rotate(45deg);
}</code></pre>
                <p>
                    <em class="purple"><strong>Rotate</strong> allows us to... rotate things.</em> We did a few examples to get a good understanding of the rotate function here: <a class="internal" href="02-intro-to-animations/transform-basics/rotations.html" target="_blank">Transform: Rotate.</a> Positive degrees are clockwise rotations while negative degrees are counter-clockwise rotations. <em class="purple">Transform-origin can be used to determine the location of where the rotate occurs from.</em>
                </p>
                <pre><code class="language-css">div { 
    /* scale would overwrite rotate if below code is used */
    transform: rotate(90deg);
    transform: scale(2);
    /* proper way - overwrites both transforms above */
    transform: rotate(90deg) scale(2);    
}</code></pre>
                <p>
                    If you tried to apply two transformations on different lines, the second transform will actually overwrite the first transform. In order to get around this, you would have to <em class="yellow">place all transformations on a single transform</em> as shown above.
                </p>
                <pre><code class="language-css">div { 
    -webkit-transform: rotate(180deg);
        -ms-transform: rotate(180deg);
            transform: rotate(180deg);
}</code></pre>
                <p>
                    <em class="yellow">Vendor prefixes are needed</em>, because as more experimental CSS properties are created, not all browsers implement them the same way or at the same time. But they clutter your workspace and can get tedious writing them all out. Also, keeping track of which are needed and which aren't is a big pain point.  To get around this, <em class="yellow">it is best to use an auto-prefixer.</em> The following is a website where you can type some code in and see the prefixes that are needed or not needed: <a href="http://autoprefixer.github.io/" target="_blank">autoprefixer</a>
                </p>
    
                <h3>CSS Transitions</h3>
                <p>
                    We have been translating, scaling, rotating, essentially moving things around, but we haven't been able to animate something yet.  We can rotate an element, but it's instantaneous and NOT animated.  <em class="yellow">Transitions allow us to control animation speed (and a few other properties) when changing CSS properties.</em> The following are the 4 transition properties that we can set for an animation:
                </p>
                <ol>
                    <li>transition-duration</li>
                    <li>transition-property</li>
                    <li>transition-timing-function</li>
                    <li>transition-delay</li>
                </ol>
                <p>A quick demo of transition basics can be found at the following link: </p>
                <pre><code class="language-css">div { 
    transition-duration: 1s;
    transition-duration: 0.5s;
    transition-duration: 3s, 1s;

    transition-property: background;
    transition-property: transform;
    transition-property: all;
    transition-property: color, opacity;

    transition-delay: 4s;
    transition-delay: 5ms, 10s;

    transition-timing-function: ease-in;
    transition-timing-function: ease-out;
    transition-timing-function: linear;
}</code></pre>
                <p>
                    <em class="blue">transition-duration is how long the transition should last.</em> You can have multiple durations if you have declared multiple different properties in your transition-property. <em class="green">transition-property allows us to specify which property should be transitioned.</em> Something to keep in mind when using transition-property is that you cannot specify just rotate or scale, and must instead use the generic transform. <em class="purple">transition-delay allows you to set how long of a pause before the transition begins.</em> You can have multiple durations if you have declared multiple different properties in your transition-property, similar to transition-duration.<em class="yellow">transition-timing-function allows you to control the "acceleration curve" for the transition.</em>  Some great examples of this can be found on the <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/transition-timing-function" target="_blank">MDN website.</a>
                </p>
                <pre><code class="language-css">div {
    /* transition: [property] [duration] [timing-function] [delay] */
    transition: opacity 1.5s ease-in 1;
}</code></pre>
                <p>
                        Instead of having to write out each of the 4 transition properties, we can simply use the shorthand for transitions as seen above. We did a few examples to get a better understanding of transitions here: <a class="internal" href="02-intro-to-animations/transition-basics/index.html" target="_blank">Transition: Basics</a>
                </p>
                <p> 
                    Although many properties can be transitioned, there are some that cannot.  A more important question however, is what properties "should" be transitioned.  <em class="yellow">If you are concerned with performance, these are the 4 properties that are recommended to be animated or transitioned</em>, all other properties have a performance hit.
                </p>
                <ol>
                    <li>transform: translate()</li>
                    <li>transform: scale()</li>
                    <li>transform: rotate()</li>
                    <li>opacity;</li>
                </ol>
                <p>
                    For more information on why all other properties are less performant, you can read this <a href="https://www.html5rocks.com/en/tutorials/speed/high-performance-animations/" target="_blank">article.</a> 
                </p>
                <p>
                    <a class="internal" href="02-intro-to-animations/transition-exercise/index.html" target="_blank">Transition: Final Exercise</a>
                </p>
    
                <h3>CSS Keyframe Animation</h3>
                <p>
                    Like transitions, keyframes are another tool in our CSS animation arsenal, but unlike transitions, they allow us to build much more complex and multi-component, multi-state animations. <em class="yellow">Transitions allow us to animate a single state change, keyframes allow for much more complex multi-state animations.</em> A very basic, and admittedly ugly, example of an animation was done here: <a class="internal" href="03-keyframes/basics/ugly-rainbow.html" target="_blank">Keyframe Basics</a>
                </p>
                <!-- <div class="media">
                    <img src="03-keyframes/imgs/keyframes-diagram-01.png" alt="">
                </div> -->
                <pre><code class="language-css">@keyframes rainbowtext {
    0% {
        color: red;
        font-size: 20px;
    }
    50% {
        color: orange;
        font-size: 40px;
    }
    100% {
        color: blue;
        font-size: 20px;
    }
}</code></pre>
                <p>
                    <em class="yellow">The first step in setting up keyframes is to define the keyframes.</em>  When defining the the keyframes, you can choose any percentage step between 0 and 100.
                </p>
                <pre><code class="language-css">div {
    /* The usual animation properties */
    animation-name: rainbowtext;
    animation-duration: 3s;
    animation-timing-function: linear;
    animation-delay: 0s;
    
    /* The "newer" animation properties */
    animation-iteration-count: infinite;
    animation-fill-mode: forwards;
    animation-direction: forward;
    animation-play-state: paused;
}</code></pre>

                <p>
                    <em class="yellow">The second step is to apply the animation</em>  Something important to note, is that there is nothing triggering the example animation above.  As soon as the page loads, the animation will start running. Also, many of the properties are similar to transitions, except for 4 new ones. The 'animation-iteration-count' property is pretty simple to understand, you just use an integer or infinite to define how many times the animation should run. In fact, here is a small demo for the animation-iteration property: <a class="internal" href="03-keyframes/basics/iteration.html" target="_blank">animation-iteration demo</a>.  However, we will go into a bit more depth with the other three.
                </p>
                <pre><code class="language-css">div {
    animation-direction: forward;
    animation-direction: reverse;
    animation-direction: alternate;
}</code></pre>
                <p>
                    <em class="blue">The animation-direction property allows us to have the animation run in reverse or even alternate</em>, which would cause it to animate forward normally, and then reverse back to the original state.  It's a bit easier to see in practice, so here is an example that we worked on: <a class="internal" href="03-keyframes/basics/direction.html" target="_blank">animation-direction demo</a>
                </p>
                <pre><code class="language-css">div {
    animation-fill-mode: forwards;
    animation-fill-mode: backwards;
    animation-fill-mode: both;
    animation-fill-mode: none;
}</code></pre>
                <p>
                    <em class="green">The animation-fill-mode property specifies how an animation should apply styles before and after the animation.</em>  It's hard to explain, so this demo helps illustrate how it works: <a class="internal" href="03-keyframes/basics/fill-mode.html" target="_blank">animation-fill-mode demo</a>. The forwards option is particularly useful when you want to run an animation one time, and then have it stay in that end state instead of having it snap back to the initial state.
                </p>
                <pre><code class="language-css">div {
    animation-play-state: paused;
    animation-play-state: running;
}</code></pre>
                <p>
                    <em class="purple">The animation-play-state property specifies whether the animation is running or paused.</em> Many times, this property is manipulated in javascript, but to keep things simple, we used the css 'hover' pseudoclass: <a class="internal" href="03-keyframes/basics/play-state.html" target="_blank">animation-play-state demo</a>
                </p>
                <pre><code class="language-css">div {
    /* first time value always goes to duration, second goes to delay */
    animation: 3s ease-in 1s 2 reverse both paused slidin;
    animation: changecolor 3s linear 1s infinite;
    animation: jiggle 4s;
}</code></pre>
                <p>
                    <em class="yellow">You can use shorthand when writing animations</em>, but if you are using many properties, it can get quite dificult to read.  The order kind of matters, but it also kind of doesn't. For example, the first value that can be parsed as a time is assigned to the animation-duration property and the second one is assigned to animation-delay. But other than that, as long as your animation-name does not conflict with the other properties, the order does not matter.
                </p>
                <p>To solidify what we have learned, we performed the following exercises:</p>
                <ul>
                    <li><a class="internal" href="03-keyframes/exercise-rising-sun/index.html" target="_blank">Rising Sun Exercise</a></li>
                    <li><a class="internal" href="03-keyframes/exercise-css-loader/index.html" target="_blank">CSS Loader</a></li>
                </ul>

                <hr />
                <h2 id="flexbox">Flexbox</h2>
                <p>
                    I haven't gotten here yet... coming soon.
                </p>
    
                <hr />
                <h2 id="async-js">Asynchronous Javascript</h2>
                <p>
                    I haven't gotten here yet... coming soon.
                </p>
    
                <hr />
                <h2 id="advanced-js">Advanced Javascript</h2>
                <p>
                    I haven't gotten here yet... coming soon.
                </p>
    
                <hr />
                <h2 id="node-mongo">Node and MongoDB</h2>
                <p>
                    I haven't gotten here yet... coming soon.
                </p>
    
                <hr />
                <h2 id="d3">D3 Data Visualization</h2>
                <p>
                    I haven't gotten here yet... coming soon.
                </p>
    
                <hr />
                <h2 id="react">React and Redux</h2>
                <p>
                    I haven't gotten here yet... coming soon.
                </p>
    
                <hr />
                <h2 id="projects">Projects</h2>
                <p>
                    I haven't gotten here yet... coming soon.
                </p>
            </div>
        </div>
    </div>

    <script src="prism/prism.js"></script>
    <script src="script.js"></script>
</body>
</html>